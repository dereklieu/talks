<!DOCTYPE html>
<html>
  <head>
    <title>Base D3 Map</title>
    <style>
      html, body { height: 100%; font-family: Helvetica, Arial; color: #333; }
      #map { width: 100%; height: 100%; }
      #loading { text-align: center; margin-top: 30%; font-size: 11px; }
      .counties {
        fill: none;
        stroke: #AAA;
        stroke-linejoin: round;
        stroke-linecap: round;
      }
      .circles {
        fill: #00cc9a;
        fill-opacity: .5;
        stroke: #fff;
        stroke-width: .5px;
      }
      line {
        stroke: #999;
      }
    </style>

  </head>
  <body>

    <div id="map">
      <p id="loading">Almost done...</p>
    </div>

    <script src="lib/d3/d3.min.js" charset="UTF-8"></script>
    <script src="lib/topojson/topojson.js"></script>
    <script src="data/2010_us_20m_topojson.js"></script>

    <script>
      var data = topojson.feature(data, data.objects['2010_us_20m']);
      console.log(data);

      var width = 960;
      var height = 800;
      var path = d3.geo.path();

      // Creating a new list to hold our bubble data.
      var nodes = [];
      for(var i = 0, ii = data.features.length; i < ii; ++i) {
        var centroid = path.centroid(data.features[i]);

        if (isNaN(centroid[0])) continue;

        centroid.x = centroid[0];
        centroid.y = centroid[1];
        centroid.feature = data.features[i];
        centroid.area = path.area(centroid.feature);

        nodes.push(centroid);
      }

      // Sort the list we just created in order of
      // descending area
      nodes = nodes.sort(function(a, b) {
        return b.area - a.area
      });

      // Since our list is now sorted, we can fill in the domain
      // using the last value as the min and the first value as
      // the max
      var scale = d3.scale.sqrt()
        .domain([nodes[nodes.length-1].area, nodes[0].area])
        .range([.5, 20]);

      var links = [];
      d3.geom.voronoi().links(nodes).forEach(function(link) {
        var dx = link.source.x - link.target.x,
          dy = link.source.y - link.target.y;
        link.distance = Math.sqrt(dx * dx + dy * dy)
        links.push(link);
      });

      var force = d3.layout.force()
        .size([width, height])
        .gravity(0)
        .nodes(nodes)
        .links(links)
        .linkDistance(function(d) { return d.distance; })
        .charge(0)
        .start();

      var svg = d3.select('#map').append('svg')
        .attr('width', width)
        .attr('height', height);

      var link = svg.selectAll('line')
        .data(links)
      .enter().append('line')
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

      var bubbles = svg.selectAll('g')
        .data(nodes)
      .enter().append('g')
        .attr('class', 'circles')
        .attr('transform', function(d) {
          return 'translate(' + -d.x + ',' + -d.y  + ')'
        })
        .call(force.drag)
      .append('circle')
        .attr('r', function(d) { return scale(d.area); })
        .attr('transform', function(d) {
          return 'translate(' + d.x + ',' + d.y + ')';
        })
        .attr('cx', function(d) { return d.x })
        .attr('cy', function(d) { return d.y })
      ;

      force.on('tick', function(e) {
        link.attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });

        bubbles.attr('transform', function(d) {
          return 'translate(' + d.x + ',' + d.y + ')';
        });
      });

      d3.select('#loading').style('display', 'none');

    </script>

  </body>
</html>
